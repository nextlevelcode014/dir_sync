# ğŸ›¡ï¸ dir_sync â€“ SincronizaÃ§Ã£o de DiretÃ³rios com Monitoramento em Tempo Real

Este projeto Ã© um utilitÃ¡rio em C que **sincroniza diretÃ³rios** recursivamente e monitora **alteraÃ§Ãµes em tempo real**, replicando as mudanÃ§as de um diretÃ³rio de origem (`source`) para um diretÃ³rio de destino (`target`).

## ğŸ”§ Funcionalidades

- ğŸ§  SincronizaÃ§Ã£o recursiva de arquivos e pastas
- ğŸ” Monitoramento contÃ­nuo usando `inotify`
- ğŸ“ Logs coloridos com descriÃ§Ã£o da aÃ§Ã£o (criaÃ§Ã£o, modificaÃ§Ã£o, exclusÃ£o)
- ğŸ§¹ Ignora arquivos temporÃ¡rios (ex: `.swp`, `4913`, `~`, `.tmp`, `.git` etc.)
- ğŸ—‚ï¸ Suporte a mÃºltiplas instÃ¢ncias para diferentes pares de pastas

---

## ğŸ—ï¸ CompilaÃ§Ã£o

VocÃª precisa de um compilador C (como GCC). Basta rodar:

```bash
make
````

Ou, para limpar e compilar:

```bash
make clean && make
```

---

## â–¶ï¸ ExecuÃ§Ã£o

```bash
./dir_sync <origem> <destino>
```

Exemplo:

```bash
./dir_sync ~/.config/nvim/ ~/dev/sysconfig/nvim/
```

> O diretÃ³rio de destino serÃ¡ sincronizado com o de origem e continuarÃ¡ sendo monitorado por novas alteraÃ§Ãµes.

---

## ğŸ“œ Ignorando arquivos temporÃ¡rios

Arquivos e padrÃµes ignorados por padrÃ£o:

* `4913` (Vim swap temporÃ¡rio)
* `*.swp`, `*.tmp`
* `*~`
* Arquivos iniciados com `.#[...]` (como `.nfsXYZ`)

A lÃ³gica estÃ¡ em `fs_utils.c`:

```c
int is_temporary_file(const char *filename) {
    return (
        strcmp(filename, "4913") == 0 ||
        fnmatch("*.swp", filename, 0) == 0 ||
        fnmatch("*~", filename, 0) == 0 ||
        fnmatch("*.tmp", filename, 0) == 0 ||
        fnmatch(".#*", filename, 0) == 0
    );
}
```

---

## ğŸ–¥ï¸ Usando com vÃ¡rios diretÃ³rios

VocÃª pode criar um script como `dir_sync_all.sh`:

```bash
#!/bin/bash

BIN="$HOME/bin/dir_sync"

$BIN "$HOME/.config/i3/" "$HOME/dev/sysconfig/i3/" &
$BIN "$HOME/.config/nvim/" "$HOME/dev/sysconfig/nvim/" &
$BIN "$HOME/.config/fish/config.fish" "$HOME/dev/sysconfig/fish/config.fish" &
$BIN "$HOME/.config/starship.toml" "$HOME/dev/sysconfig/starship/starship.toml" &
$BIN "/etc/X11/xorg.conf.d/" "$HOME/dev/sysconfig/xorg.conf.d/" &
$BIN "/etc/optimus-manager/" "$HOME/dev/sysconfig/optimus-manager/" &

wait
```

DÃª permissÃ£o de execuÃ§Ã£o:

```bash
chmod +x dir_sync_all.sh
```

E execute:

```bash
./dir_sync_all.sh
```

---

## âœ… Criar um serviÃ§o systemd

Criar um arquivo de unidade em:

```
~/.config/systemd/user/dir_sync.service
```

ConteÃºdo do arquivo:
 ```
[Unit]
Description=Monitoramento contÃ­nuo de arquivos com dir_sync
After=network.target

[Service]
ExecStart=%h/bin/dir_dir_sync_all.sh
Restart=on-failure
Environment=DISPLAY=:0
Environment=XAUTHORITY=%h/.Xauthority

[Install]
WantedBy=default.target
 ```
Recarregue o systemd e habilite o serviÃ§o
```
systemctl --user daemon-reexec
systemctl --user daemon-reload
systemctl --user enable --now dir_sync.service
```
Verifique se estÃ¡ rodando
```
systemctl --user status dir_sync.service
```
Logs
```
journalctl --user -u dir_sync.service -f
```
---

## ğŸ“ Estrutura do Projeto

```
dir_sync/
â”œâ”€â”€ main.c
|-- config.c/.h
â”œâ”€â”€ watcher.c/.h        # Lida com inotify
|-- utils.c/.h          # Lida com a logica do sistema de arquivos
â”œâ”€â”€ Makefile
â”œâ”€â”€ dir_sync_all.sh         # Script opcional para rodar vÃ¡rias instÃ¢ncias
â””â”€â”€ README.md
```

---

## ğŸ§© DependÃªncias

* Linux
* Biblioteca padrÃ£o C (glibc)
* Header `<sys/inotify.h>`

---

## ğŸ“œ LicenÃ§a

MIT. Livre para modificar e usar.